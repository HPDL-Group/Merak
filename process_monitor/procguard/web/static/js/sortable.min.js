/**
 * SimpleSortable - Lightweight drag and drop library
 * MIT License - Copyright (c) 2024
 */
(function(global) {
    'use strict';

    let globalDraggedItem = null;
    let globalDraggedFromGroup = null;

    class SimpleSortable {
        constructor(container, options = {}) {
            this.container = typeof container === 'string' 
                ? document.querySelector(container) 
                : container;
            this.options = {
                group: options.group || 'shared',
                animation: options.animation || 150,
                onEnd: options.onEnd || null,
                onAdd: options.onAdd || null,
                onRemove: options.onRemove || null,
                filter: options.filter || '',
                handle: options.handle || null,
                ...options
            };
            
            this.container.style.position = 'relative';
            this.container.style.minHeight = '50px';
            
            this.container.addEventListener('dragstart', this.handleDragStart.bind(this));
            this.container.addEventListener('dragend', this.handleDragEnd.bind(this));
            this.container.addEventListener('dragover', this.handleDragOver.bind(this));
            this.container.addEventListener('dragleave', this.handleDragLeave.bind(this));
            this.container.addEventListener('drop', this.handleDrop.bind(this));
            
            this.container.setAttribute('data-sortable-group', this.options.group);
        }

        createPlaceholder(element) {
            const placeholder = document.createElement('div');
            placeholder.className = 'sortable-placeholder';
            placeholder.style.height = element.offsetHeight + 'px';
            placeholder.style.background = '#e3f2fd';
            placeholder.style.border = '2px dashed #2196F3';
            placeholder.style.margin = '4px 0';
            placeholder.style.borderRadius = '4px';
            return placeholder;
        }

        handleDragStart(e) {
            if (this.options.filter && e.target.closest(this.options.filter)) {
                e.preventDefault();
                return;
            }
            
            if (this.options.handle && !e.target.closest(this.options.handle)) {
                return;
            }

            const draggedItem = e.target.closest('[draggable="true"]');
            if (!draggedItem) return;

            draggedItem.classList.add('dragging');
            draggedItem.style.opacity = '0.5';
            e.dataTransfer.effectAllowed = 'move';
            e.dataTransfer.setData('text/plain', draggedItem.dataset.workerId);
            
            this.placeholder = this.createPlaceholder(draggedItem);
            
            const groupId = this.container.dataset.groupId || 'default';
            globalDraggedItem = draggedItem;
            globalDraggedFromGroup = groupId;
        }

        handleDragEnd(e) {
            if (globalDraggedItem) {
                globalDraggedItem.classList.remove('dragging');
                globalDraggedItem.style.opacity = '1';
            }
            
            if (this.placeholder && this.placeholder.parentNode) {
                this.placeholder.remove();
                this.placeholder = null;
            }
            
            document.querySelectorAll('.sortable-placeholder').forEach(el => el.remove());
            document.querySelectorAll('.sortable-over').forEach(el => el.classList.remove('sortable-over'));
            
            globalDraggedItem = null;
            globalDraggedFromGroup = null;
        }

        handleDragOver(e) {
            e.preventDefault();
            e.dataTransfer.dropEffect = 'move';
            
            const container = e.target.closest('[data-sortable-group]');
            if (!container) return;
            
            container.classList.add('sortable-over');
            
            const afterElement = this.getAfterElement(container, e.clientY);
            if (afterElement) {
                container.insertBefore(this.placeholder, afterElement);
            } else {
                container.appendChild(this.placeholder);
            }
        }

        handleDragLeave(e) {
            const container = e.target.closest('[data-sortable-group]');
            if (container && !container.contains(e.relatedTarget)) {
                container.classList.remove('sortable-over');
            }
        }

        handleDrop(e) {
            e.preventDefault();
            
            const targetContainer = e.target.closest('[data-sortable-group]');
            if (!targetContainer || !globalDraggedItem) return;

            targetContainer.classList.remove('sortable-over');
            
            const newGroup = targetContainer.dataset.groupId;
            const oldGroup = globalDraggedFromGroup;
            const workerId = globalDraggedItem.dataset.workerId;
            
            if (this.placeholder && this.placeholder.parentNode) {
                this.placeholder.parentNode.insertBefore(globalDraggedItem, this.placeholder);
            }
            
            if (oldGroup !== newGroup) {
                if (this.options.onRemove) {
                    this.options.onRemove({ 
                        item: globalDraggedItem, 
                        from: oldGroup, 
                        to: newGroup 
                    });
                }
                
                if (this.options.onAdd) {
                    this.options.onAdd({ 
                        item: globalDraggedItem, 
                        from: oldGroup, 
                        to: newGroup 
                    });
                }
            }
            
            if (this.options.onEnd) {
                this.options.onEnd({ 
                    item: globalDraggedItem, 
                    from: oldGroup, 
                    to: newGroup 
                });
            }
        }

        getAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('[draggable="true"]:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        destroy() {
            this.container.removeEventListener('dragstart', this.handleDragStart);
            this.container.removeEventListener('dragend', this.handleDragEnd);
            this.container.removeEventListener('dragover', this.handleDragOver);
            this.container.removeEventListener('dragleave', this.handleDragLeave);
            this.container.removeEventListener('drop', this.handleDrop);
        }
    }

    global.SimpleSortable = SimpleSortable;
})(window);
